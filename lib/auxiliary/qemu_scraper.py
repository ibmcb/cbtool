#!/usr/bin/env python

import sys, libvirt, json, re, socket, os
from time import sleep, time
from logging import getLogger, StreamHandler, Formatter, Filter, DEBUG, ERROR, INFO, WARN, CRITICAL
from xdrlib import Packer, Unpacker
from sys import path

cwd = (re.compile(".*\/").search(os.path.realpath(__file__)).group(0)) + "/../../"
path.append(cwd)
from lib.api.api_service_client import *
from lib.auxiliary.code_instrumentation import trace, cbdebug, cberr, cbwarn, cbinfo, cbcrit

try :
    # Provided by RHEL 6.2
    from libvirt_qemu import qemuMonitorCommand
    from libvirt import virEventRegisterDefaultImpl
    from libvirt import virEventAddHandle
    from libvirt import virEventRunDefaultImpl
except ImportError:
    cberr("QEMU scraper cannot run without qemuMonitorCommand", True)
    exit(1)

slope_str2int = {'zero':0,
                 'positive':1,
                 'negative':2,
                 'both':3,
                 'unspecified':4}

# could be autogenerated from previous but whatever
slope_int2str = {0: 'zero',
                 1: 'positive',
                 2: 'negative',
                 3: 'both',
                 4: 'unspecified'}

class Gmetric:
    """
    Class to send gmetric/gmond 2.X packets

    Thread safe
    """

    type = ('', 'string', 'uint16', 'int16', 'uint32', 'int32', 'float',
            'double', 'timestamp')
    protocol = ('udp', 'multicast')

    def __init__(self, host, port, protocol):
        if protocol not in self.protocol:
            raise ValueError("Protocol must be one of: " + str(self.protocol))

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        if protocol == 'multicast':
            self.socket.setsockopt(socket.IPPROTO_IP,
                                   socket.IP_MULTICAST_TTL, 20)
        self.hostport = (host, int(port))
        #self.socket.connect(self.hostport)

    def send(self, NAME, VAL, TYPE='', UNITS='', SLOPE='both',
             TMAX=60, DMAX=0, GROUP="", SPOOF=""):
        if SLOPE not in slope_str2int:
            raise ValueError("Slope must be one of: " + str(self.slope.keys()))
        if TYPE not in self.type:
            raise ValueError("Type must be one of: " + str(self.type))
        if len(NAME) == 0:
            raise ValueError("Name must be non-empty")

        ( meta_msg, data_msg )  = gmetric_write(NAME, VAL, TYPE, UNITS, SLOPE, TMAX, DMAX, GROUP, SPOOF)

        self.socket.sendto(meta_msg, self.hostport)
        self.socket.sendto(data_msg, self.hostport)

def gmetric_write(NAME, VAL, TYPE, UNITS, SLOPE, TMAX, DMAX, GROUP, SPOOF):
    """
    Arguments are in all upper-case to match XML
    """
    packer = Packer()
    HOSTNAME="test"
    if SPOOF == "":
        SPOOFENABLED=0
    else :
        SPOOFENABLED=1
    # Meta data about a metric
    packer.pack_int(128)
    if SPOOFENABLED == 1:
        packer.pack_string(SPOOF)
    else:
        packer.pack_string(HOSTNAME)
    packer.pack_string(NAME)
    packer.pack_int(SPOOFENABLED)
    packer.pack_string(TYPE)
    packer.pack_string(NAME)
    packer.pack_string(UNITS)
    packer.pack_int(slope_str2int[SLOPE]) # map slope string to int
    packer.pack_uint(int(TMAX))
    packer.pack_uint(int(DMAX))
    # Magic number. Indicates number of entries to follow. Put in 1 for GROUP
    if GROUP == "":
        packer.pack_int(0)
    else:
        packer.pack_int(1)
        packer.pack_string("GROUP")
        packer.pack_string(GROUP)

    # Actual data sent in a separate packet
    data = Packer()
    data.pack_int(128+5)
    if SPOOFENABLED == 1:
        data.pack_string(SPOOF)
    else:
        data.pack_string(HOSTNAME)
    data.pack_string(NAME)
    data.pack_int(SPOOFENABLED)
    data.pack_string("%s")
    data.pack_string(str(VAL))

    return ( packer.get_buffer() ,  data.get_buffer() )

def list_domains(cloud_name, lvirt_conns, api, uuid) :
    domains = {}
    ips = {}
    status = True

    app = api.appshow(cloud_name, uuid) 
    metric_vm = api.vmshow(cloud_name, app["metric_aggregator_vm"])
    metric_defaults = api.cldshow(cloud_name, "mon_defaults")
    metric_port = metric_defaults["collector_vm_port"]

    for vm_parts in app["vms"].split(",") :
        vm_uuid, role, vm_name = vm_parts.split("|")
        vm = api.vmshow(cloud_name, vm_uuid)
        if "host_cloud_ip" not in vm :
            continue

        host_ip = vm["host_cloud_ip"]
        if vm_uuid in lvirt_conns :
            lvirt_conns[vm_uuid].close()

        lvirt_conns[vm_uuid] = libvirt.open("qemu+tcp://" + host_ip + "/system")
        domains[vm_uuid] = lvirt_conns[vm_uuid].lookupByName(vm["cloud_uuid"])
        ips[vm_uuid] = vm["cloud_ip"]

    return status, domains, ips, metric_vm["cloud_ip"], metric_port

def deliver(g, freq_str, key, value, spoof) :
    unit = "n/a"
    num = False
    typ = "n/a"
    try :
        num = int(value)
        unit = "ms"
        typ = "int32"
    except ValueError :
        try :
            num = float(value)
            unit = "mbps"
            typ = "float"
            g.send(key, str(value), "float", "mbps", "both", freq_str, "0", "mc", spoof)
        except ValueError :
            pass

    if num is not False :
        g.send("qemu_" + key.replace("-", "_"), str(num), typ, unit, "both", freq_str, "0", "mc", spoof)

def get_stats_all_domains(g, freq_str, ips, domains, agg_ip) :
    for name in domains :
        dom = domains[name]
        stats = qemuMonitorCommand(dom, "{\"execute\": \"query-status\"}", 0)
        migrate = qemuMonitorCommand(dom, "{\"execute\": \"query-migrate\"}", 0)
        stats = json.loads(stats)
        migrate = json.loads(migrate)
        stats.update(migrate)
        mem = dom.memoryStats()
        ip = ips[name]
        if not ip :
            continue

        spoof = ip + ":" + ip
        print "domain: " + str(name) + " ip " + str(ip) + " uuid: " + str(dom.UUIDString()) + " stats: " + str(stats) + " qemu: " + str(mem) + "\n"

        g.send("qemu_max", str(mem["actual"]), "int32", "KB", "both", freq_str, "0", "memory", spoof)
        g.send("qemu_rss", str(mem["rss"]), "int32", "KB", "both", freq_str, "0", "memory", spoof)

        for key in stats["return"] :
            value = stats["return"][key]
            
            if isinstance(value, str) :
                deliver(g, freq_str, key, value, spoof)
            elif isinstance(value, dict) :
                for subkey in stats["return"][key] :
                    value = stats["return"][key][subkey]
                    deliver(g, freq_str, subkey, value, spoof)
                    

def qemu_scraper(options) :
    cbdebug("Will use API Service @ http://" + options.apihost + ":" + str(options.apiport))

    apihost = options.apihost
    apiport = options.apiport
    last_refresh = str(time())

    if apihost == "0.0.0.0" :
            apihost = "127.0.0.1"

    api_access = "http://" + apihost + ":" + str(apiport)
    api = APIClient(api_access)
    g = None
    freq = 5
    freq_str = str(freq)
    count = 0
    lvirt_conns = {}

    while True :
        try :
            if count == 0 or api.should_refresh(options.cn, last_refresh) :
                last_refresh = str(time())
                count = 10 
                (status, domains, ips, agg_ip, agg_port) = list_domains(options.cn, lvirt_conns, api, options.ouuid)
                g = Gmetric(agg_ip, str(agg_port), "udp")
                print "Found " + str(len(domains)) + " domains"

            if not status :
                print "Listing domains failed! darn."
            else :
                get_stats_all_domains(g, freq_str, ips, domains, agg_ip)
        except APIException, msg :
            print "Failed to perform API Actions before QEMU: " + str(msg)

        except Exception, msg:
            print "Failure: " + str(msg)
            try :
                count = 1
            except Exception, msg:
                print "Failed to re-list during failure: " + str(msg)
                pass
            
            print "Failed to deliver metrics: " + str(msg)

        sleep(freq)
        count -= 1
